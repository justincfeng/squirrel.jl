var documenterSearchIndex = {"docs":
[{"location":"metrics.html#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"metrics.html#Kerr-Schild-metric","page":"Metrics","title":"Kerr-Schild metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The Kerr-Schild metric takes the form:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"    g_mu nu = eta_mu nu + f  k_mu  k_nu ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"where ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"  k_mu = left( 1  fracr  x + a  yr^2+a^2\n                 fracr  y - a  xr^2+a^2  fraczrright)","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"  f = frac2  G  M  r^3r^4+a^2  z^2","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"and r is implicitly defined by:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"fracx^2+y^2r^2+a^2 + fracz^2r^2 = 1 ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The components of the Kerr-Schild metric can be calculated using gks function in general","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.gks","category":"page"},{"location":"metrics.html#squirrel.metric.gks","page":"Metrics","title":"squirrel.metric.gks","text":"gks( X::RealVec , a::Real=0 , GM::Real=1 )\n\nThe gks function takes a point X in Cartesian Kerr-Schild  coordinates and calculates the components of the Kerr-Schild metric at  that point in a Kerr spacetime with rotation parameter a and with the  product of gravitational constant and mass GM\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"or using the ge function for Earth-like parameters","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.ge","category":"page"},{"location":"metrics.html#squirrel.metric.ge","page":"Metrics","title":"squirrel.metric.ge","text":"ge( X::RealVec )\n\nThe ge function takes a point X in Cartesian Kerr-Schild  coordinates and calculates the components of the Kerr-Schild metric at  that point in a Kerr spacetime with relation between mass and angular  momentum roughly corresponding to the Earth value (a=738GM)\n\n\n\n\n\n","category":"function"},{"location":"metrics.html#Weak-field-metric","page":"Metrics","title":"Weak field metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"For solar system and terrestrial positioning, the weak field metric suffices. The weak field metric has the form:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"g_mu nu = eta_mu nu - 2  V  delta_mu nu","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"where V is the gravitational potential.","category":"page"},{"location":"metrics.html#Gordon-metric","page":"Metrics","title":"Gordon metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"To incorporate atmospheric and ionospheric effects, one uses the analogue Gordon metric, which takes the form (with g_mu nu being the gravitational metric):","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"    barg_mu nu = g_mu nu + \n    left(1-frac1n^2right) u_mu u_nu ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The general Gordon metric is implemented in the following function:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.gGordon","category":"page"},{"location":"metrics.html#squirrel.metric.gGordon","page":"Metrics","title":"squirrel.metric.gGordon","text":"gGordon( X::RealVec , n::Function=nIR , gfunc::Function=giso , \n         U::RealVec=Float64[-1;0;0;0] )\n\nThe function gGordon computes the Gordon metric. The argument n can be replaced with a user-supplied index of refraction function, the argument gfunc can be replaced with a user-supplied background metric, and the argument U can be replaced with a user-supplied fluid  four-velocity function.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"In principle, the function implemented above can be used with any user defined index of refraction profile. However, for evaluation purposes, we implement some simplified index of refraction profiles in the following sections.","category":"page"},{"location":"metrics.html#Index-of-refraction-models","page":"Metrics","title":"Index of refraction models","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The index of refraction is written in the following form:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"n = 1 + Delta n_rm atm + Delta n_rm ion","category":"page"},{"location":"metrics.html#Atmospheric-component","page":"Metrics","title":"Atmospheric component","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The atmospheric component for the index of refraction is given here as a function of the height h from the surface of the Earth:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"Delta n_atm = fracA_1B_1 + C_1 left(h-H_1)right)\n  + fracA_2B_2 + C_2 left(h-H_2)right)","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"with the parameter choices:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    A_1 = -222666    qquad   A_2 = -253499  \n    B_1 = 990621     qquad   B_2 = 112757  \n    C_1 = 0157823 textkm^-1\n        qquad C_2 = 0179669 textkm^-1\n    H_1 = -71541  textkm\n        qquad   H_2 = -715654 textkm\nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The function Delta n_atm is implemented in the following:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.ΔnatmStd","category":"page"},{"location":"metrics.html#squirrel.metric.ΔnatmStd","page":"Metrics","title":"squirrel.metric.ΔnatmStd","text":"ΔnatmStd( h::Real )\n\nThe function ΔnatmStd is a profile for the atmospheric index of  of refraction obtained from the U. S. standard atmosphere data. The argument h is height from the Earth's surface in km.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html#Ionospheric-component","page":"Metrics","title":"Ionospheric component","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The ionospheric component index of refraction is given by the following:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    Delta n_ion approx \n              left(4024 times 10^-17right) N_etextm^-3\nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"where the electron density is given by:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    N_e = bigglalpha_D  tilde Ep(hh_Db_D)\n          + alpha_E  tilde Ep(hh_Eb_E) \n          + alpha_F  tilde Ep(hh_Fb_F)biggr\nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"with the parameter choices:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    alpha_D = 10^12textm^-3\n                   quad   h_D =  75textkm\n                   quad   b_D =   5textkm \n    alpha_E = 25 times 10^11textm^-3\n                   quad   h_E = 130textkm\n                   quad   b_E =  30textkm \n    alpha_F = 10^11textm^-3\n                   quad   h_F = 300textkm\n                   quad   b_F =  50textkm \nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The function tilde Ep(hh_Eb_E) is the pseudo-Epstein function:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    tilde Ep(hh_cB) = frac116\n    biggl\n      left1+left(tfrach-h_c2 Bright)^2right^-1\n      +left1+left(tfrach-h_c4 Bright)^2right^-2\n      +left1+left(tfrach-h_c6 Bright)^2right^-3\n      +left1+left(tfrach-h_c7 Bright)^2right^-4\n      biggr^2\nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"defined as:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.pEp","category":"page"},{"location":"metrics.html#squirrel.metric.pEp","page":"Metrics","title":"squirrel.metric.pEp","text":"pEp( h , hc , B , Nmax )\n\nThe function pEp implements the pseudo-Epstein line shape function used to approximate the Epstein function used to construct the  ionospheric electron density profiles.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The ionospheric index of refraction, also written in terms of the height h from the surface of the Earth, is implemented in the following: ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.Δnios","category":"page"},{"location":"metrics.html#squirrel.metric.Δnios","page":"Metrics","title":"squirrel.metric.Δnios","text":"Δnios( h::Real , θ::Real , ϕ::Real )\n\nThe function Δnios provides a crude model for the ionospheric electron density profile. The variable h represents height from the Earth's surface in units of km.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The unperturbed total index of refraction Delta n_rm tot = Delta n_rm atm + Delta n_rm ion is given in the following (in surface-adapted coordinates):","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.Δntot","category":"page"},{"location":"metrics.html#squirrel.metric.Δntot","page":"Metrics","title":"squirrel.metric.Δntot","text":"Δntot( h::Real , θ::Real , ϕ::Real )\n\nThe function Δntot is the total index of refraction profile, which is a sum of atmospheric and ionospheric index of refraction profiles.  The variable h represents height from the Earth's surface in units of  km.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html#Perturbation-models","page":"Metrics","title":"Perturbation models","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"To model uncertainties in the index of refraction profile, perturbations of the following form are introduced (also in surface-adapted coordinates):","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"beginaligned\n    Delta n_rm pert = Delta n_rm atm left(1\n                 + delta_1  tilde p_1(h) right) \n     qquad \n    + Delta n_rm ion left(1 + delta_2  tilde  p_2(h)right)\nendaligned","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"and implemented in the following.","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.Δntp","category":"page"},{"location":"metrics.html#squirrel.metric.Δntp","page":"Metrics","title":"squirrel.metric.Δntp","text":"Δntp( h::Real , θ::Real , ϕ::Real , δ1::Real=0.001\n           , δ2::Real=0.010 , Patm::Function=h->1.0\n           , Pion::Function=h->1.0 )\n\nThe function Δntp adds the perturbations provided in the perturbation model to the atmospheric and ionospheric profiles defined earlier.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The respective perturbation profile function p_A and line shape function Ls are defined:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"tilde p_A(h) = sum_i alpha_i tilde Ls(hh_0isigma_i)","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.P","category":"page"},{"location":"metrics.html#squirrel.metric.P","page":"Metrics","title":"squirrel.metric.P","text":"P( h::Real , h0::RealVec , σ::RealVec )\n\nThe function P constructs the perturbation model, which consists of a sum of line shape functions LSF, with the parameters provided in the vector arguments h0 and σ.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"Ls(hh_0sigma) =  fracsigma^2sigma^2 \n                      + (h-h_0)^2 fracsigma^4\n                        sigma^4 + (h-h_0)^4","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.LSF","category":"page"},{"location":"metrics.html#squirrel.metric.LSF","page":"Metrics","title":"squirrel.metric.LSF","text":"LSF( x , xo , σ )\n\nThe function LSF implements a line shape function employed in the perturbation models; it has a faster falloff than the Lorentzian.\n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The parameters h_i and  sigma_i are fed into the perturbation profile functions as vectors.","category":"page"},{"location":"metrics.html#Conversion-functions","page":"Metrics","title":"Conversion functions","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"Index of refraction functions are converted from surface-adapted coordinates to spherical coordinates with the following function:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.nIRs","category":"page"},{"location":"metrics.html#squirrel.metric.nIRs","page":"Metrics","title":"squirrel.metric.nIRs","text":"nIRs( RE::Real , r::Real , θ::Real , ϕ::Real , Δnf::Function )\n\nThe function nIRs computes the index of refraction in spherical coordinates from the index of refraction profile function Δnf in spherical coordinates. \n\n\n\n\n\n","category":"function"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"Finally, the index of refraction functions are converted to Cartesian coordinates with the following function:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"squirrel.metric.nIR","category":"page"},{"location":"metrics.html#squirrel.metric.nIR","page":"Metrics","title":"squirrel.metric.nIR","text":"nIR( X::RealVec , Δnf::Function=Δntot )\n\nThe function nIR computes the index of refraction in Cartesian coordinates; the profile is anchored to the WGS84 ellipsoid defined by the rell function.\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html#Geodesic-solver","page":"Geodesic solver","title":"Geodesic solver","text":"","category":"section"},{"location":"geodesics.html#Null-Geodesics:-Hamilton's-equations","page":"Geodesic solver","title":"Null Geodesics: Hamilton's equations","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Null geodesics in a spacetime geometry described by a metric g_μν may be described by the Hamiltonian:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"H = frac12 g^μν p_μ p_ν","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"and the associated Hamilton equations:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdx^μdλ = fracHp_μ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdp_μdλ = - fracHx^μ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The conjugate momenta p_μ are defined as:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"p_μ = g_μν fracdx^νdλ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"and for null geodesics, the initial data satisfies:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"leftδ^i_μ fracdx^μdλright_λ=0 = bf v^i","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"left g_μν(x_0) \nfracdx^μdλfracdx^νdλ right_λ=0 = 0","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The solution to Hamilton's equations is formally given by x^μ=x^μ(λx_0bf v) (with x_0 denoting the initial position of the geodesic), and since λ (being an affine parameter) can be redefined linearly, it is appropriate to set up the problem so that λ01, with λ=0 being the initial point and λ=1 is the final point.","category":"page"},{"location":"geodesics.html#Implementation","page":"Geodesic solver","title":"Implementation","text":"","category":"section"},{"location":"geodesics.html#Hamiltonian","page":"Geodesic solver","title":"Hamiltonian","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The Hamiltonian function takes the form:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.HamGeo","category":"page"},{"location":"geodesics.html#squirrel.HamGeo","page":"Geodesic solver","title":"squirrel.HamGeo","text":"HamGeo( Z::RealVec , gfunc::Function )\n\nThe HamGeo function computes the geodesic Hamiltonian  H = frac12 g^μν p_μ p_ν from the metric g_μν provided in the function gfunc and the  spacetime position x and momentum p encoded in Z=(x,p).\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html#Hamilton's-equations","page":"Geodesic solver","title":"Hamilton's equations","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Hamilton's equations may be written in terms of the phase space coordinate z^α, where z=(xp).","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdz^αdλ = J^αβ fracHz^β","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"where J^αβ is the symplectic matrix, which has the block matrix form:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"J =\nleft\n  beginarraycccc\n     O    I  \n     -I    O  \n  endarray\nright","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"where O is a 44 matrix of zeros and I is the identity matrix. The symplectic matrix is implemented as an operator acting on a vector Hz^β:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.Jsympl","category":"page"},{"location":"geodesics.html#squirrel.Jsympl","page":"Geodesic solver","title":"squirrel.Jsympl","text":"Jsympl( Zarg::RealVec )\n\nThe Jsympl function effectively applies the symplectic matrix J^αβ to the vector Zarg (the vector Hz^β).\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The quantity J^αβ fracHz^β is evaluated in the following function: ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.ZdotGeo","category":"page"},{"location":"geodesics.html#squirrel.ZdotGeo","page":"Geodesic solver","title":"squirrel.ZdotGeo","text":"ZdotGeo( Z::RealVec , gfunc::Function )\n\nThe ZdotGeo function computes the gradient of the Hamiltonian and applies the symplectic operator to the gradient.\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html#Geodesic-solver-function","page":"Geodesic solver","title":"Geodesic solver function","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Geodesics are solved with the following function, which outputs the endpoint (λ=1) of the solution to Hamilton's equations:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.solveZ","category":"page"},{"location":"geodesics.html#squirrel.solveZ","page":"Geodesic solver","title":"squirrel.solveZ","text":"solveZ( Z0::RealVec , gfunc::Function , δ1::Real , δ2::Real ,\n        integrator=AutoVern7(Rodas5()) , δt=0 )\n\nThe function solveZ performs the integration of geodesics given the initial data Z0, and the metric function gfunc. The integration is performed using the integrator specified by the variable integrator using the relative tolerance parameter δ1 and the absolute tolerance  parameter δ2. The parameter δt determines the timestep parameter  dt in ODEProblem. \n\nThe function solveZ outputs only the endpoint of the solution for the geodesic equation.\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Following the recommendations in the ODE Solver documentation for the OrdinaryDiffEq.jl library, the integrators AutoVern7(Rodas5()) and AutoVern9(Rodas5()) are used in squirrel.jl.","category":"page"},{"location":"index.html#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Relativistic positioning refers to the concept of establishing spacetime positions from proper time broadcasts emitted by a system of satellites. Central to relativistic positioning is the relativistic location problem,  which is the problem of finding the intersection of future pointing light cones from a collection of at least four emission points. Algorithms for relativistic location in flat spacetime are provided in the cereal.jl package. This package, squirrel.jl, contains a collection of functions for the relativistic location problem in slightly curved spacetime geometries.","category":"page"},{"location":"index.html#Short-tutorial","page":"Home","title":"Short tutorial","text":"","category":"section"},{"location":"index.html#Setup","page":"Home","title":"Setup","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The squirrel.jl code was written for and tested in Julia 1.6; we recommend Julia 1.6 or newer. In this terminal it is assumed that one can invoke Julia directly from the command line/terminal by typing the\ncommand","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"as is typically the case for installations on linux distributions (Ubuntu and Manjaro for instance). For detailed instructions on how to set this up, please refer to the platform specific  installation instructions for Julia.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To add the code, run the following command in the package manager for the Julia REPL (the package manager can be opened by typing ]):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add https://github.com/justincfeng/squirrel.jl/","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Once added, one may access the squirrel module with the following command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using squirrel","category":"page"},{"location":"index.html#Positioning-examples","page":"Home","title":"Positioning examples","text":"","category":"section"},{"location":"index.html#Vacuum-case","page":"Home","title":"Vacuum case","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"One begins by defining a metric. The Kerr-Schild metric for a rotating object with the mass and angular momentum of the Earth is given by the following function:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> gks = squirrel.metric.ge","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The resulting function gks takes a four-component vector xc=[t,x,y,z] (representing spacetime coordinates) as an argument, and returns a 44 matrix of metric components. The units are normalized to Earth mass (1 length unit = 0.4435 cm), and chosen so that the speed of light is 1. One can randomly generate a target point Xtar and a set of 5 emission points X on the past light cone of Xtar with the following:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> (X,Xtar) = squirrel.seval.pgen(6e9,gks,1e-14,5) ;","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The first argument in the function on the left hand side specifies (roughly) the spatial radius of the emission points from the origin, and the third argument specified the tolerance for the geodesic integrator. The target point Xtar is placed on the WGS84 reference ellipsoid (defined with respect to the Cartesian Kerr-Schild coordinates).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The intersection of future light cones from the emission points is computed with the squirrel.locator function:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Xs = squirrel.locator(X,gks,1e-10)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The third argument is the tolerance for the geodesic solvers; the tolerance is looser here to minimize computation time. The accuracy of the result may be estimated by comparing Xs and Xtar:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ΔX = Xs-Xtar","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Upon multiplying by the conversion factor 0.4435 to obtain the result in units of centimeters (0.4435*ΔX), one typically obtains a result well in the submillimeter range. The relative error may be obtained by running:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> squirrel.norm(ΔX)/squirrel.norm(Xtar)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and one typically obtains errors on the order of sim 10^-11 - 10^-13.","category":"page"},{"location":"index.html#Including-atmospheric-and-ionospheric-effects","page":"Home","title":"Including atmospheric and ionospheric effects","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"One can incorporate the effects of the atmosphere and ionosphere with the following metric:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> g = squirrel.metric.g","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This metric is the Gordon metric for light propagatation through media; here, a simple model for the atmosphere and ionosphere is implemented. One may repeat the steps of the vacuum case to obtain the errors:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> (Xn,Xntar) = squirrel.seval.pgen(6e9,g,1e-14,5) ;\n\njulia> Xns = squirrel.locator(Xn,g,1e-10)\n\njulia> ΔXn = Xns-Xntar\n\njulia> 0.4435*ΔXn\n\njulia> squirrel.norm(ΔXn)/squirrel.norm(Xntar)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In this case, one typically finds that the errors are larger than the vacuum case by an order of magnitude, though still in the submillimeter range. ","category":"page"},{"location":"index.html#Benchmarking","page":"Home","title":"Benchmarking","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"For benchmarking, it is best to start Julia with four threads enabled. This can be done by starting Julia from the command line/terminal with  the command (to exit the Julia REPL, run the command julia> exit()):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia --threads 4","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The number of threads can be verified with the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> Threads.nthreads()","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To determine the execution time, one may use the package (BenchmarkTools](https://github.com/JuliaCI/BenchmarkTools.jl). Once installed, one first runs the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using BenchmarkTools","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"One should then run the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> using squirrel\njulia> gks = squirrel.metric.ge\njulia> g   = squirrel.metric.g\njulia> (X,Xtar)   = squirrel.seval.pgen(6e9,gks,1e-14,6) ;\njulia> (Xn,Xntar) = squirrel.seval.pgen(6e9,g,1e-14,6)   ;","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Julia employs Just-In-Time (JIT) compilation. Practically, this means that the first time a function is executed, additional time is required to compile the code. For this reason, it is recommended that the following functions are run first before performing execution time benchmarks:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> squirrel.locator(X,gks,1e-10) ;\njulia> squirrel.locator(Xn,g,1e-10)  ;","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The execution time may be determined by running the following commands:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> @btime squirrel.locator(Xn,gks,1e-10,4)\njulia> @btime squirrel.locator(Xn,gks,1e-10,5)\njulia> @btime squirrel.locator(Xn,gks,1e-10,6)\n\njulia> @btime squirrel.locator(X,g,1e-10,4)\njulia> @btime squirrel.locator(X,g,1e-10,5)\njulia> @btime squirrel.locator(X,g,1e-10,6)","category":"page"},{"location":"index.html#Evaluation","page":"Home","title":"Evaluation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"It is recommended that the evaluation scripts are run with four threads; as indicated in the Benchmarks section, one can do this from the command line/terminal command julia --threads 4.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Scripts are provided for a more comprehensive evaluation of the accuracy and performance of the functions in squirrel.jl. To find the scripts directory, run the command:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> pathscript = dirname(dirname(pathof(squirrel)))*\"/scripts/\"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which should return a string with the path to the scripts directory. Before running the scripts, one should make the following directory (this will throw an error if a directory already exists):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> mkdir(dirname(dirname(pathof(squirrel)))*\"/res/\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To generate the samples, one should first change to the scripts directory","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> cd(pathscript)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"and then run the samplegen.jl script (which may require installation of the CoordinateTransformations and LegendrePolynomials packages):","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> include(\"samplegen.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This will generate 1000 samples. Once the samples have been generated, run the evaluation script:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> include(\"evaluation.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"which will evaluate the locator functions in squirrel.jl for 1000 test cases, and for the terrestrial positioning problem in four geometries: the Kerr-Schild metric, the Gordon metric for an analogue Gordon metric modeling atmospheric and ionospheric effects and two perturbed Gordon metrics corresponding to fractional uncertainties of up 1  to 10 in the ionospheric electron density (and a 01 uncertainty in the atmospheric index of refraction). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The results can be plotted with the scripts:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> include(\"plotresults.jl\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The results are located in the following res directory:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> dirname(dirname(pathof(squirrel)))*\"/res/\"","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If one wishes to change the parameters of the sample generation and evaluation scripts (for instance, if one wishes to increase the number of test cases), one should make a copy of the repository, make changes to the files in the scripts folder of the repository (the parameters of the script plotresults.jl should be changed accordingly). One may then run the edited scripts in the scripts folder.","category":"page"},{"location":"evaluation.html#Evaluation-functions","page":"Evaluation","title":"Evaluation functions","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The functions described here are contained in the seval submodule. These functions are encapsulated so that they provide a somewhat independent evaluation of the locator functions in the squirrel.jl code. At present, the parameters of the evaluation functions have values corresponding to terrestrial positioning.","category":"page"},{"location":"evaluation.html#Basic-strategy","page":"Evaluation","title":"Basic strategy","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The functions in seval, particularly seval.gen and seval.main, may be used to evaluate the accuracy of the locator functions implemented in squirrel.jl according to the following strategy:","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"Generate (stochastically) a target point Xtar.\nGenerate ne emission points X on the past light cone of Xtar  by solving the geodesic equation for some metric g.\nFeed the emission points X and metric g into the  squirrel.locator or squirrel.locator4 function and compare with  target point Xtar.","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The function seval.gen is implements steps 1. and 2., and the function seval.main implements step 3.","category":"page"},{"location":"evaluation.html#Structs-and-format-conversion-functions","page":"Evaluation","title":"Structs and format conversion functions","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The evaluation submodule seval defines two datatypes, one for the generation of test cases (TestCases), and one for storing the results of the evaluation (TestData).","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.TestCases","category":"page"},{"location":"evaluation.html#squirrel.seval.TestCases","page":"Evaluation","title":"squirrel.seval.TestCases","text":"The TestCases datatype may be populated by the associated function of the form:\n\nTestCases( par::NTuple , N::Int , ne::Int , X::Array{RealMtx,1} , Xtar::Array{RealVec,1} )\n\nThe variables are defined in the following way:\n\npar     ::  NTuple              # Parameter tuple\nN       ::  Int                 # Number of generated test cases\nne      ::  Int                 # Number of emission points\nX       ::  Array{RealMtx,1}    # Emission points\nXtar    ::  Array{RealVec,1}    # Target point\n\n\n\n\n\n","category":"type"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.TestData","category":"page"},{"location":"evaluation.html#squirrel.seval.TestData","page":"Evaluation","title":"squirrel.seval.TestData","text":"The TestData datatype may be populated by the associated function of the form:\n\nTestData(   par::NTuple , N::Int    , \n            X::Array{RealMtx,1}     ,   Xtar::Array{RealVec,1}     ,\n            Xc::Array{RealVec,1}    ,   Xsc::Array{RealVec,1}      ,\n            erh::RealVec    ,   erv::RealVec    ,   err::RealVec   ,\n            erhC::RealVec   ,   ervC::RealVec   ,   errC::RealVec  ,\n            Xc2::Array{RealVec,1}   ,   Xsc2::Array{RealVec,1}     ,\n            erh2::RealVec   ,   erv2::RealVec   ,   err2::RealVec  ,\n            erhC2::RealVec  ,   ervC2::RealVec  ,   errC2::RealVec )\n\nThe quantities are defined in the following way:\n\npar     ::  NTuple              # Parameter tuple\nN       ::  Int                 # Number of cases\nX       ::  Array{RealMtx,1}    # Emission points\nXtar    ::  Array{RealVec,1}    # Target point\nXc      ::  Array{RealVec,1}    # Flat spacetime position\nXsc     ::  Array{RealVec,1}    # Squirrel position\nerh     ::  RealVec             # Horizontal error relative to Xsc\nerv     ::  RealVec             # Vertical error relative to Xsc\nerr     ::  RealVec             # Total error relative to Xsc\nerhC    ::  RealVec             # Horizontal error relative to Xc\nervC    ::  RealVec             # Vertical error relative to Xc\nerrC    ::  RealVec             # Total error relative to Xc\nXc2     ::  Array{RealVec,1}    # Flat spacetime position     (Aux.)\nXsc2    ::  Array{RealVec,1}    # Squirrel position      (Auxiliary)\nerh2    ::  RealVec             # Horizontal errors      (Auxiliary)\nerv2    ::  RealVec             # Vertical error         (Auxiliary)\nerr2    ::  RealVec             # Total error            (Auxiliary)\nerhC2   ::  RealVec             # Horizontal errors      (Auxiliary)\nervC2   ::  RealVec             # Vertical error         (Auxiliary)\nerrC2   ::  RealVec             # Total error            (Auxiliary)\n\nThe quantities suffixed with 2 are auxiliary quantities which are needed in the four-point case, in which the special relativistic location algorithms generally suffer from the bifurcation problem.\n\n\n\n\n\n","category":"type"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The functions seval.gen and seval.main can generate large amounts of data. The data may be saved to a file using Julia's built in serializer, but it is recommended that the data be converted to a tuple. The following functions may be used to convert the between tuples and the  TestCases/TestData datatypes:","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.tc2tup","category":"page"},{"location":"evaluation.html#squirrel.seval.tc2tup","page":"Evaluation","title":"squirrel.seval.tc2tup","text":"tc2tup( tc::TestCases )\n\nThe tc2tup function changes tc from an object of type TestCases to  a tuple.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.td2tup","category":"page"},{"location":"evaluation.html#squirrel.seval.td2tup","page":"Evaluation","title":"squirrel.seval.td2tup","text":"td2tup( td::TestData )\n\nThe td2tup function changes td from an object of type TestData to  a tuple.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.tup2tc","category":"page"},{"location":"evaluation.html#squirrel.seval.tup2tc","page":"Evaluation","title":"squirrel.seval.tup2tc","text":"tup2tc( tctup::Tuple )\n\nThe tc2tup function changes tctup from a Tuple to an object of type  TestCases.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.tup2td","category":"page"},{"location":"evaluation.html#squirrel.seval.tup2td","page":"Evaluation","title":"squirrel.seval.tup2td","text":"tup2td( tdtup::Tuple )\n\nThe td2tup function changes tdtuple from a Tuple to an object of  type TestData.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"In some cases, one may wish to change to a higher precision floating point type for the generated samples. For this purpose, the following function is provided:","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.tcfl","category":"page"},{"location":"evaluation.html#squirrel.seval.tcfl","page":"Evaluation","title":"squirrel.seval.tcfl","text":"tcfl( tc::TestCases , tpfl::DataType=Float64 )\n\nThe tcfl function changes the floating point type of tc to tpfl.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#Test-case-generation","page":"Evaluation","title":"Test case generation","text":"","category":"section"},{"location":"evaluation.html#Point-generation","page":"Evaluation","title":"Point generation","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"Emission points are generated on the past light cone of a target point. The idea is to stochastically generate a target point Xtar, and then generate initial data for N past-directed null geodesics, which are then integrated to obtain the emission points.","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.pgen","category":"page"},{"location":"evaluation.html#squirrel.seval.pgen","page":"Evaluation","title":"squirrel.seval.pgen","text":"pgen( Rs::Real , gfunc::Function , tol::Real , ne::Int=4 , \n      Δψ::Real=Δψ0 )\n\nThe pgen function generates a target point Xtar and ne emission points in a 4×ne matrix X such that the points in X lie on the past light cone of Xtar with respect to the metric gfunc, and have spatial radii values of ~Rs (defined with respect to spatial origin). The parameter tol is the tolerance parameter for the integration. This function returns the tuple (X,Xtar).\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#Multiple-case-generator","page":"Evaluation","title":"Multiple case generator","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The following function generates N sets of target points Xtar and emission points X. It returns a quantity of datatype TestCases.","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.gen","category":"page"},{"location":"evaluation.html#squirrel.seval.gen","page":"Evaluation","title":"squirrel.seval.gen","text":"gen( N::Int , g::Function , ne::Int=4 , Δψ::Real=Δψ0 \n          , tpfl::DataType=Float64 \n          , REs ::  Real=1.4365276211950395e9       # Earth radius\n          , RR  ::  Real=1.4365277e9    # Just above Earth surface\n          , Rs  ::  Real=6e9            # Satellite radius\n          , tolh::  Real=1e-14          # Tolerance for ODE solvers\n          , tol ::  Real=1e-10          # Tolerance for ODE solvers\n        )\n\nThe gen function generates N sets of target points Xtar and  emission points X with respect to the metric gfunc. This function returns a quantity of the TestCases datatype.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#Evaluation-function","page":"Evaluation","title":"Evaluation function","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"The following is the main evaluation function. It returns a quantity of datatype TestData.","category":"page"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.main","category":"page"},{"location":"evaluation.html#squirrel.seval.main","page":"Evaluation","title":"squirrel.seval.main","text":"main(  tc::TestCases , sloc::Function , g::Function , Nx::Int=-1 , \n       tpfl::DataType=Double64 , tol::Real=1e-10 , ξ::Real=2e1 , \n       nb::Int=24 , ne::Real=6 )\n\nThis is the main evaluation function. It takes as input a collection of test cases contained in a quantity of datatype TestCases, and evaluates the squirrel locator function sloc on each test case relative to a given metric function g. The function main returns results in a quantity of type TestData.\n\nThe variable Nx is a limiter for the number of test cases to run. The variable tpfl specifies the floating point precision for the calculations. variables tol, ξ, nb,  and ne are inputs for the sloc function, and correspond respectively to the integration tolerance, outlier detection threshold, number of steps for the Broyden algorithm, and number of emission points.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Squirrel-algorithm","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"","category":"section"},{"location":"squirrel.html#Description","page":"Squirrel algorithm","title":"Description","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The squirrel algorithm takes the coordinates of n_rm e  4 emission points, arranged as column vectors in a 4n_rm e matrix X,  and computes the intersection of future pointing null geodesics defined with respect to a (slightly curved) spacetime metric g. ","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Null geodesics may be described as solutions to the geodesic equation (implemented here in the form of Hamilton's equations), which may be formally written as the functions:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"    x^μ_I(λX_Ibf v_I)","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"where the indices I12n_rm e distinguish the emission points X_I and their associated null geodesics, and bf v_I denotes the spatial components of the initial four-velocity vector for the null geodesic (the time component is determined by the requirement that the four-velocity is null). ","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Given a collection of four geodesic functions x_1x_2x_3x_4 (each having the form x^μ_I=x^μ_I(λx_0bf v)), the condition that they intersect is the vanishing of the following vector-valued function:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"f = left( x_1 - x_2  x_1 - x_3  x_1 - x_4 right)","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"which may be formally written as f=f(X_1X_2X_3X_4bf v_1bf v_2bf v_3bf v_4). A variable counting exercise reveals that f has 12 components; since there are a total of 12 undetermined quantities in the four initial velocities bf v_I (each of which have three components), the condition f=0 can thought of as a set of 12 equations for the 12 unknowns v_I. The squirrel algorithm seeks to find the roots of the function f.","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The squirrel algorithm is then summarized:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Apply the flat spacetime algorithm to the emission points X to  obtain an initial guess for the zeros of the function f.\nApply a root finding algorithm to the function f to obtain the  initial velocities v_I.\nIntegrate the geodesics with the resulting initial velocities  v_I and emission points X to find the intersection point.","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"A quasi-Newton Broyden algorithm (which will be described in detail below) is employed to do the root-finding; in such a method, the Jacobian for f is computed once in the first iteration of the root finding algorithm, and is updated in the subsequent iterations. The function f is computed by way of numerical integration of geodesics; if the numerical integration is performed using native Julia libraries, one can compute the Jacobian by way of automatic differentiation.","category":"page"},{"location":"squirrel.html#Geodesic-endpoint-function","page":"Squirrel algorithm","title":"Geodesic endpoint function","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"To compute the function f, the geodesic endpoint function x^μ_I=x^μ_I(λX_Ibf v_I)_λ=1 is implemented using the native Julia ODE solvers in the library OrdinaryDiffEq.jl, using the recommended method AutoVern7(Rodas5())","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.gsolve","category":"page"},{"location":"squirrel.html#squirrel.gsolve","page":"Squirrel algorithm","title":"squirrel.gsolve","text":"gsolve( Xi::RealVec , Vi::RealVec , g::Function , tol::Real , integrator=AutoVern7(Rodas5()) )\n\nThe gsolve function takes an initial point Xi and four velocity Vi and computes the endpoint of a future pointing null geodesic in the metric func g. The variable integrator specifies the integration scheme, and tol is the tolerance parameter.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"With the geodesic endpoint functions x^μ_I=x^μ_I(λX_Ibf v_I)_λ=0 in hand, one can construct the function f=f(X_Ibf v_I):","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.zF","category":"page"},{"location":"squirrel.html#squirrel.zF","page":"Squirrel algorithm","title":"squirrel.zF","text":"zF( Vid::RealVec , Zi::RealMtx , g::Function , tol::Real )\n\nThe function zF returns differences between the endpoints of four geodesics for the initial data encoded in Vid and Zi, and the metric function g. The variable tol is the tolerance parameter for the integration. This function vanishes when the four geodesics intersect.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Jacobian","page":"Squirrel algorithm","title":"Jacobian","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Next, one computes the Jacobian of f. As mentioned earlier, this is done by way of automatic differentiation, using the library ForwardDiff.jl. Here, the Jacobian matrix of x^μ_I=x^μ_I(λX_Ibf v_I)_λ=1 (which one may write schematically as fracx_Iv_J) is computed:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.gejac","category":"page"},{"location":"squirrel.html#squirrel.gejac","page":"Squirrel algorithm","title":"squirrel.gejac","text":"gejac( Xi::RealVec , Vi::RealVec , g::Function , δ::Real )\n\nThe function gejac computes the endpoint of a geodesic and its Jacobian. The variables have the same meaning as those in gsolve.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Given fracx_Iv_J, the Jacobian matrix of the function f may be computed by way of the chain rule, as indicated in the schematic formula:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"J = fracfx_Ifracx_Iv_J","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The following function applies the chain rule to compute the Jacobian matrix:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.geocJ","category":"page"},{"location":"squirrel.html#squirrel.geocJ","page":"Squirrel algorithm","title":"squirrel.geocJ","text":"geocJ( Zi::RealMtx , g::Function , δ::Real )\n\nThe function geocJ computes the Jacobian of the function zF from the Jacobian endpoints computed in gejac.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Root-finding-algorithm","page":"Squirrel algorithm","title":"Root finding algorithm","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Given some function f(x), the standard approach is the Newton method, which finds the roots according to the prescription:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"    x_i+1 = x_i + bf J^-1_i f(x_i)","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"where bf J^-1_i is the inverse of the Jacobian matrix bf J for f(x) evaluated at x_i. However, in situations which the computation of the Jacobian matrix bf J becomes expensive, one may instead employ the Broyden method, which is a quasi-Newton root finding method. The Broyden algorithm involves first computing the Jacobian matrix bf J and its inverse for f(x). However, instead of computing the Jacobian matrix at each iteration (as is done in the Newton method), the Broyden algorithm updates the (inverse) Jacobian matrix according to the Sherman-Morrison update formula:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"    bf J^-1_i+1 \n    = \n        bf J^-1_i\n        +\n        fracΔv^T_i - bf J^-1_i Δf_i \n        Δv^T_i bf J^-1_i Δf_i \n        Δv^T_i bf J^-1_i","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"which is implemented in the following function:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.JiSMU","category":"page"},{"location":"squirrel.html#squirrel.JiSMU","page":"Squirrel algorithm","title":"squirrel.JiSMU","text":"JiSMU( ΔF::RealVec , Δx::RealVec , Ji::RealMtx )\n\nThe function JiSMU implements the Sherman-Morrison update formula.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The Broyden update formula is implemented in the following function:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.bsolve","category":"page"},{"location":"squirrel.html#squirrel.bsolve","page":"Squirrel algorithm","title":"squirrel.bsolve","text":"bsolve( F::Function , J::RealMtx , f0::RealVec , x0::RealVec ,\n        nb::Int=24 )\n\nThe function bsolve implements the Broyden algorithm; in particular, it finds the roots of the function F(x), given the Jacobian matrix J and the initial guesses f0 and x0. The parameter nb specifies the maximum number of iterations.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Initial-data-finder","page":"Squirrel algorithm","title":"Initial data finder","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The following function makes use of the preceding functions to construct the initial data for the four-velocities:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.idf","category":"page"},{"location":"squirrel.html#squirrel.idf","page":"Squirrel algorithm","title":"squirrel.idf","text":"idf( Zi::RealMtx , gfunc::Function , tol::Real , nb::Int )\n\nThe function idf applies the Broyden algorithm to the function zF, using the Jacobian initially computed with geocJ.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Locator-(Four-points)","page":"Squirrel algorithm","title":"Locator (Four points)","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"Finally, the locator4 function computes the intersection point from a set of four emission points X by first employing the idf function to obtain the initial data for the geodesics, and integrates the geodesics (up to unit affine parameter λ) to obtain the intersection point:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.locator4","category":"page"},{"location":"squirrel.html#squirrel.locator4","page":"Squirrel algorithm","title":"squirrel.locator4","text":"locator4( X::RealMtx , Xc::RealVec , gfunc::Function , tol::Real , nb::Int=24 , idv::Bool=false , V::RealMtx=zeros(Float64,4,4) )\n\nThe function locator4 computes the intersection point from a set of four emission points X using the guess Xc. The intersection point is computed by first finding the initial data using the function idf, then integrating geodesics to obtain the result. If an improved guess for the four-velocities is available, one can set ìdv=true and specify the four-velocities as column vectors in the matrix V.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Locator-(n_e4-emission-points)","page":"Squirrel algorithm","title":"Locator (n_e4 emission points)","text":"","category":"section"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"If more than four emission points are available, the following function can generate C(n_rm e4) sets of emission points (where C(nk) is the binomial coefficient):","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.combX","category":"page"},{"location":"squirrel.html#squirrel.combX","page":"Squirrel algorithm","title":"squirrel.combX","text":"combX( X::RealMtx )\n\nThe combX function constructs and returns a vector of 44 matrices consisting of all choices of 4 column vectors from the 4n_rm e matrix X.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"One feeds the output of combX into the locator4 function to obtain C(n_rm e4) solutions. The following outlier detection formula, which is based on the comparison with median values, can then be used to exclude large errors (the assumption here is that the large errors are infreqent):","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.odetc","category":"page"},{"location":"squirrel.html#squirrel.odetc","page":"Squirrel algorithm","title":"squirrel.odetc","text":"odetc( XC::Vector , ξ::Real=1e1 )\n\nThe odetc function takes a vector of vectors as input and returns a vector of the vectors that differ by less than a threshold of ξ.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"The following function implements the procedure described above, given a matrix of 4n_rm e emission points X:","category":"page"},{"location":"squirrel.html","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"squirrel.locator","category":"page"},{"location":"squirrel.html#squirrel.locator","page":"Squirrel algorithm","title":"squirrel.locator","text":"locator( X::RealMtx , gfunc::Function , δ::Real , ne::Int=5 , nb::Int=24 , outthresh::Real=2e1 , tpflc::DataType=Double64 )\n\nThe function locator computes the intersection point from a set of ne>4 emission points X by applying locator4 to all combinations of 4 points out of ne in X. A basic outlier detection algorithm (implemented in the function odetc) is applied to reduce errors.\n\n\n\n\n\n","category":"function"}]
}
