var documenterSearchIndex = {"docs":
[{"location":"metrics.html#Metrics","page":"Metrics","title":"Metrics","text":"","category":"section"},{"location":"metrics.html#Kerr-Schild-metric","page":"Metrics","title":"Kerr-Schild metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"The Kerr-Schild metric takes the form:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"    g_mu nu = eta_mu nu + f  k_mu  k_nu ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"where ","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"  k_mu = left( fracr  x + a  yr^2+a^2\n                 fracr  y - a  xr^2+a^2 fraczrright)","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"  f = frac2  G  M  r^3r^4+a^2  z^2","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"and r is implicitly defined by:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"fracx^2+y^2r^2+a^2 + fracz^2r^2 = 1 ","category":"page"},{"location":"metrics.html#Weak-field-metric","page":"Metrics","title":"Weak field metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"For solar system and terrestrial positioning, the weak field metric suffices. The weak field metric has the form:","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"g_mu nu = eta_mu nu - 2  V  delta_mu nu","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"where V is the gravitational potential.","category":"page"},{"location":"metrics.html#Gordon-metric","page":"Metrics","title":"Gordon metric","text":"","category":"section"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"To incorporate atmospheric and ionospheric effects, one uses the analogue Gordon metric, which takes the form (with g_mu nu being the gravitational metric):","category":"page"},{"location":"metrics.html","page":"Metrics","title":"Metrics","text":"    barg_mu nu = g_mu nu + left(1-frac1n^2right) u_mu u_nu ","category":"page"},{"location":"geodesics.html#Geodesic-solver","page":"Geodesic solver","title":"Geodesic solver","text":"","category":"section"},{"location":"geodesics.html#Null-Geodesics","page":"Geodesic solver","title":"Null Geodesics","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Null geodesics in a spacetime geometry described by a metric g_μν are described by the Hamiltonian:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"H = frac12 g^μν p_μ p_ν","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"and the associated Hamilton equations:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdx^μdλ = fracHp_μ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdp_μdλ = - fracHx^μ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The conjugate momenta p_μ are defined as:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"p_μ = g_μν fracdx^νdλ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"and for null geodesics, the initial data satisfies:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"leftδ^i_μ fracdx^μdλright_λ=0 = bf v^i","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"left g_μν(x_0) \nfracdx^μdλfracdx^νdλ right_λ=0 = 0","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The solution to Hamilton's equations is formally given by x^μ=x^μ(λx_0bf v), and since λ (being an affine parameter) can be redefined linearly, it is appropriate to set up the problem so that λ01, with λ=0 being the initial point and λ=1 is the final point.","category":"page"},{"location":"geodesics.html#Implementation","page":"Geodesic solver","title":"Implementation","text":"","category":"section"},{"location":"geodesics.html#Hamiltonian","page":"Geodesic solver","title":"Hamiltonian","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The Hamiltonian function takes the form:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.HamGeo","category":"page"},{"location":"geodesics.html#squirrel.HamGeo","page":"Geodesic solver","title":"squirrel.HamGeo","text":"HamGeo( Z::RealVec , gfunc::Function )\n\nThe HamGeo function computes the geodesic Hamiltonian  H = \frac12 g^μν p_μ p_ν from the metric g_μν provided in the function gfunc and the  spacetime position x and momentum p encoded in Z=(x,p).\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html#Hamilton's-equations","page":"Geodesic solver","title":"Hamilton's equations","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Hamilton's equations may be written in terms of the phase space coordinate z^α, where z=(xp).","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"fracdz^αdλ = J^αβ fracHz^β","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"where J^αβ is the symplectic matrix, which has the block matrix form:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"J =\nleft\n  beginarraycccc\n     O    I  \n     -I    O  \n  endarray\nright","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"where O is a 44 matrix of zeros and I is the identity matrix. The symplectic matrix is implemented as an operator acting on a vector Hz^β:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.Jsympl","category":"page"},{"location":"geodesics.html#squirrel.Jsympl","page":"Geodesic solver","title":"squirrel.Jsympl","text":"Jsympl( Zarg::RealVec )\n\nThe Jsympl function effectively applies the symplectic matrix J^αβ to the vector Zarg (the vector Hz^β).\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The quantity J^αβ fracHz^β is evaluated in the following function: ","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.ZdotGeo","category":"page"},{"location":"geodesics.html#squirrel.ZdotGeo","page":"Geodesic solver","title":"squirrel.ZdotGeo","text":"ZdotGeo( Z::RealVec , gfunc::Function )\n\nThe ZdotGeo function computes the gradient of the Hamiltonian and applies the symplectic operator to the gradient.\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"The symplectic operator ","category":"page"},{"location":"geodesics.html#Geodesic-solver-function","page":"Geodesic solver","title":"Geodesic solver function","text":"","category":"section"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Geodesics are solved with the following function, which outputs the endpoint (λ=1) of the solution to Hamilton's equations:","category":"page"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"squirrel.solveZ","category":"page"},{"location":"geodesics.html#squirrel.solveZ","page":"Geodesic solver","title":"squirrel.solveZ","text":"solveZ( Z0::RealVec , gfunc::Function , δ1::Real , δ2::Real ,\n        integrator=AutoVern7(Rodas5()) , δt=0 )\n\nThe function solveZ performs the integration of geodesics given the initial data Z0, and the metric function gfunc. The integration is performed using the integrator specified by the variable integrator using the relative tolerance parameter δ1 and the absolute tolerance  parameter δ2. The parameter δt determines the timestep parameter  dt in ODEProblem. \n\nThe function solveZ outputs only the endpoint of the solution for the geodesic equation.\n\n\n\n\n\n","category":"function"},{"location":"geodesics.html","page":"Geodesic solver","title":"Geodesic solver","text":"Following the recommendations in the ODE Solver documentation, the integrators AutoVern7(Rodas5()) and AutoVern9(Rodas5()) are used in squirrel.jl.","category":"page"},{"location":"index.html#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Relativistic positioning refers to the concept of establishing spacetime positions from proper time broadcasts emitted by a system of satellites. Central to relativistic positioning is the relativistic location location problem, which is the problem of finding the intersection of future pointing light cones from a collection of at least four emission points. squirrel.jl contains a collection of functions for the relativistic location problem in slightly curved spacetime geometries.","category":"page"},{"location":"index.html#Short-tutorial","page":"Home","title":"Short tutorial","text":"","category":"section"},{"location":"index.html#Other-methods","page":"Home","title":"Other methods","text":"","category":"section"},{"location":"index.html#Evaluation","page":"Home","title":"Evaluation","text":"","category":"section"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"evaluation.html#Evaluation","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation.html#Examples","page":"Evaluation","title":"Examples","text":"","category":"section"},{"location":"evaluation.html#Structs","page":"Evaluation","title":"Structs","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.TestCases","category":"page"},{"location":"evaluation.html#squirrel.seval.TestCases","page":"Evaluation","title":"squirrel.seval.TestCases","text":"The TestCases datatype may be populated by the associated function of the form:\n\nTestCases( par::NTuple , N::Int , np::Int , X::Array{RealMtx,1} , Xtar::Array{RealVec,1} )\n\nThe variables are defined in the following way:\n\npar     ::  NTuple              # Parameter tuple\nN       ::  Int                 # Number of generated test cases\nnp      ::  Int                 # Number of emission points\nX       ::  Array{RealMtx,1}    # Emission points\nXtar    ::  Array{RealVec,1}    # Target point\n\n\n\n\n\n","category":"type"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.TestData","category":"page"},{"location":"evaluation.html#squirrel.seval.TestData","page":"Evaluation","title":"squirrel.seval.TestData","text":"The TestData datatype may be populated by the associated function of the form:\n\nTestData(   par::NTuple , N::Int    , \n            X::Array{RealMtx,1}     ,   Xtar::Array{RealVec,1}     ,\n            Xc::Array{RealVec,1}    ,   Xsc::Array{RealVec,1}      ,\n            erh::RealVec    ,   erv::RealVec    ,   err::RealVec   ,\n            erhC::RealVec   ,   ervC::RealVec   ,   errC::RealVec  ,\n            Xc2::Array{RealVec,1}   ,   Xsc2::Array{RealVec,1}     ,\n            erh2::RealVec   ,   erv2::RealVec   ,   err2::RealVec  ,\n            erhC2::RealVec  ,   ervC2::RealVec  ,   errC2::RealVec )\n\nThe quantities are defined in the following way:\n\npar     ::  NTuple              # Parameter tuple\nN       ::  Int                 # Number of cases\nX       ::  Array{RealMtx,1}    # Emission points\nXtar    ::  Array{RealVec,1}    # Target point\nXc      ::  Array{RealVec,1}    # Flat spacetime position\nXsc     ::  Array{RealVec,1}    # Squirrel position\nerh     ::  RealVec             # Horizontal error relative to Xsc\nerv     ::  RealVec             # Vertical error relative to Xsc\nerr     ::  RealVec             # Total error relative to Xsc\nerhC    ::  RealVec             # Horizontal error relative to Xc\nervC    ::  RealVec             # Vertical error relative to Xc\nerrC    ::  RealVec             # Total error relative to Xc\nXc2     ::  Array{RealVec,1}    # Flat spacetime position     (Aux.)\nXsc2    ::  Array{RealVec,1}    # Squirrel position      (Auxiliary)\nerh2    ::  RealVec             # Horizontal errors      (Auxiliary)\nerv2    ::  RealVec             # Vertical error         (Auxiliary)\nerr2    ::  RealVec             # Total error            (Auxiliary)\nerhC2   ::  RealVec             # Horizontal errors      (Auxiliary)\nervC2   ::  RealVec             # Vertical error         (Auxiliary)\nerrC2   ::  RealVec             # Total error            (Auxiliary)\n\nThe quantities suffixed with 2 are auxiliary quantities which are needed in the four-point case, in which the special relativistic location algorithms generally suffer from the bifurcation problem.\n\n\n\n\n\n","category":"type"},{"location":"evaluation.html#Test-case-generation","page":"Evaluation","title":"Test case generation","text":"","category":"section"},{"location":"evaluation.html#Point-generation","page":"Evaluation","title":"Point generation","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.pgen","category":"page"},{"location":"evaluation.html#squirrel.seval.pgen","page":"Evaluation","title":"squirrel.seval.pgen","text":"pgen( Rs::Real , gfunc::Function , tol::Real , np::Int=4 , \n      Δψ::Real=Δψ0 )\n\nThe pgen function generates a target point Xtar and np emission points in a 4×np matrix X such that the points in X lie on the past light cone of Xtar with respect to the metric gfunc, and have spatial radii values of ~Rs (defined with respect to spatial origin). The parameter tol is the tolerance parameter for the integration. This function returns the tuple (X,Xtar).\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#Multiple-case-generator","page":"Evaluation","title":"Multiple case generator","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.gen","category":"page"},{"location":"evaluation.html#squirrel.seval.gen","page":"Evaluation","title":"squirrel.seval.gen","text":"gen( N::Int , g::Function , np::Int=4 , Δψ::Real=Δψ0 \n          , tpfl::DataType=Float64 \n          , REs ::  Real=1.4365276211950395e9       # Earth radius\n          , RR  ::  Real=1.4365277e9    # Just above Earth surface\n          , Rs  ::  Real=6e9            # Satellite radius\n          , tolh::  Real=1e-14          # Tolerance for ODE solvers\n          , tol ::  Real=1e-10          # Tolerance for ODE solvers\n        )\n\nThe gen function generates N sets of target points Xtar and  emission points X with respect to the metric gfunc. This function returns a quantity of the TestCases datatype.\n\n\n\n\n\n","category":"function"},{"location":"evaluation.html#Evaluation-2","page":"Evaluation","title":"Evaluation","text":"","category":"section"},{"location":"evaluation.html","page":"Evaluation","title":"Evaluation","text":"squirrel.seval.main","category":"page"},{"location":"evaluation.html#squirrel.seval.main","page":"Evaluation","title":"squirrel.seval.main","text":"main(  tc::TestCases , sloc::Function , g::Function , Nx::Int=-1 , \n       tpfl::DataType=Double64 , tol::Real=1e-10 , ξ::Real=2e1 , \n       nb::Int=24 , ne::Real=6 )\n\nThis is the main evaluation function. It takes as input a collection of test cases contained in a quantity of datatype TestCases, and evaluates the squirrel locator function sloc on each test case relative to a given metric function g. The function main returns results in a quantity of type TestData.\n\nThe variable Nx is a limiter for the number of test cases to run. The variable tpfl specifies the floating point precision for the calculations. variables tol, ξ, nb,  and ne are inputs for the sloc function, and correspond respectively to the integration tolerance, outlier detection threshold, number of steps for the Broyden algorithm, and number of emission points.\n\n\n\n\n\n","category":"function"},{"location":"squirrel.html#Squirrel-algorithm","page":"Squirrel algorithm","title":"Squirrel algorithm","text":"","category":"section"}]
}
