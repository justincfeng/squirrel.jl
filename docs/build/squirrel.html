<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Squirrel algorithm · squirrel.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">squirrel.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="metrics.html">Metrics</a></li><li><a class="tocitem" href="geodesics.html">Geodesic solver</a></li><li class="is-active"><a class="tocitem" href="squirrel.html">Squirrel algorithm</a><ul class="internal"><li><a class="tocitem" href="#Description"><span>Description</span></a></li><li><a class="tocitem" href="#Geodesic-endpoint-function"><span>Geodesic endpoint function</span></a></li><li><a class="tocitem" href="#Jacobian"><span>Jacobian</span></a></li><li><a class="tocitem" href="#Root-finding-algorithm"><span>Root finding algorithm</span></a></li><li><a class="tocitem" href="#Initial-data-finder"><span>Initial data finder</span></a></li><li><a class="tocitem" href="#Locator-(Four-points)"><span>Locator (Four points)</span></a></li><li><a class="tocitem" href="#Locator-(n_e4-emission-points)"><span>Locator (<span>$n_e&gt;4$</span> emission points)</span></a></li></ul></li><li><a class="tocitem" href="evaluation.html">Evaluation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="squirrel.html">Squirrel algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="squirrel.html">Squirrel algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/justincfeng/squirrel.jl/blob/master/docs/src/squirrel.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Squirrel-algorithm"><a class="docs-heading-anchor" href="#Squirrel-algorithm">Squirrel algorithm</a><a id="Squirrel-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Squirrel-algorithm" title="Permalink"></a></h1><h2 id="Description"><a class="docs-heading-anchor" href="#Description">Description</a><a id="Description-1"></a><a class="docs-heading-anchor-permalink" href="#Description" title="Permalink"></a></h2><p>The squirrel algorithm takes the coordinates of <span>$n_{\rm e} ≥ 4$</span> emission points, arranged as column vectors in a <span>$4×n_{\rm e}$</span> matrix <span>$X$</span>,  and computes the intersection of future pointing null geodesics defined with respect to a (slightly curved) spacetime metric <code>g</code>. </p><p>Null geodesics may be described as solutions to the geodesic equation (implemented here in the form of Hamilton&#39;s equations), which may be formally written as the functions:</p><p class="math-container">\[    x^μ_I(λ,{X}_I,{\bf v}_I),\]</p><p>where the indices <span>$I∈\{1,2,...,n_{\rm e}\}$</span> distinguish the emission points <span>$X_I$</span> and their associated null geodesics, and <span>${\bf v}_I$</span> denotes the spatial components of the initial four-velocity vector for the null geodesic (the time component is determined by the requirement that the four-velocity is null). </p><p>Given a collection of four geodesic functions <span>$\{x_1,x_2,x_3,x_4\}$</span> (each having the form <span>$x^μ_I=x^μ_I(λ,{x}_0,{\bf v})$</span>), the condition that they intersect is the vanishing of the following vector-valued function:</p><p class="math-container">\[f := \left( x_1 - x_2 , x_1 - x_3 , x_1 - x_4 \right)\]</p><p>which may be formally written as <span>$f=f(X_1,X_2,X_3,X_4,{\bf v}_1,{\bf v}_2,{\bf v}_3,{\bf v}_4)$</span>. A variable counting exercise reveals that <span>$f$</span> has <span>$12$</span> components; since there are a total of 12 undetermined quantities in the four initial velocities <span>${\bf v}_I$</span> (each of which have three components), the condition <span>$f=0$</span> can thought of as a set of <span>$12$</span> equations for the <span>$12$</span> unknowns <span>$v_I$</span>. The squirrel algorithm seeks to find the roots of the function <span>$f$</span>.</p><p>The squirrel algorithm is then summarized:</p><ol><li><p>Apply the flat spacetime algorithm to the emission points <span>$X$</span> to  obtain an initial guess for the zeros of the function <span>$f$</span>.</p></li><li><p>Apply a root finding algorithm to the function <span>$f$</span> to obtain the  initial velocities <span>$v_I$</span>.</p></li><li><p>Integrate the geodesics with the resulting initial velocities  <span>$v_I$</span> and emission points <span>$X$</span> to find the intersection point.</p></li></ol><p>A quasi-Newton Broyden algorithm (which will be described in detail below) is employed to do the root-finding; in such a method, the Jacobian for <span>$f$</span> is computed once in the first iteration of the root finding algorithm, and is updated in the subsequent iterations. The function <span>$f$</span> is computed by way of numerical integration of geodesics; if the numerical integration is performed using native Julia libraries, one can compute the Jacobian by way of automatic differentiation.</p><h2 id="Geodesic-endpoint-function"><a class="docs-heading-anchor" href="#Geodesic-endpoint-function">Geodesic endpoint function</a><a id="Geodesic-endpoint-function-1"></a><a class="docs-heading-anchor-permalink" href="#Geodesic-endpoint-function" title="Permalink"></a></h2><p>To compute the function <span>$f$</span>, the geodesic endpoint function <span>$x^μ_I=x^μ_I(λ,X_I,{\bf v}_I)|_{λ=1}$</span> is implemented using the native Julia ODE solvers in the library <a href="https://github.com/SciML/OrdinaryDiffEq.jl"><code>OrdinaryDiffEq.jl</code></a>, using the recommended method <code>AutoVern7(Rodas5())</code></p><article class="docstring"><header><a class="docstring-binding" id="squirrel.gsolve" href="#squirrel.gsolve"><code>squirrel.gsolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gsolve( Xi::RealVec , Vi::RealVec , g::Function , tol::Real , integrator=AutoVern7(Rodas5()) )</code></pre><p>The <code>gsolve</code> function takes an initial point <code>Xi</code> and four velocity <code>Vi</code> and computes the endpoint of a future pointing null geodesic in the metric func <code>g</code>. The variable <code>integrator</code> specifies the integration scheme, and <code>tol</code> is the tolerance parameter.</p></div></section></article><p>With the geodesic endpoint functions <span>$x^μ_I=x^μ_I(λ,X_I,{\bf v}_I)|_{λ=0}$</span> in hand, one can construct the function <span>$f=f(X_I,{\bf v}_I)$</span>:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.zF" href="#squirrel.zF"><code>squirrel.zF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">zF( Vid::RealVec , Zi::RealMtx , g::Function , tol::Real )</code></pre><p>The function <code>zF</code> returns differences between the endpoints of four geodesics for the initial data encoded in <code>Vid</code> and <code>Zi</code>, and the metric function <code>g</code>. The variable <code>tol</code> is the tolerance parameter for the integration. This function vanishes when the four geodesics intersect.</p></div></section></article><h2 id="Jacobian"><a class="docs-heading-anchor" href="#Jacobian">Jacobian</a><a id="Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian" title="Permalink"></a></h2><p>Next, one computes the Jacobian of <span>$f$</span>. As mentioned earlier, this is done by way of automatic differentiation, using the library <a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>ForwardDiff.jl</code></a>. Here, the Jacobian matrix of <span>$x^μ_I=x^μ_I(λ,X_I,{\bf v}_I)|_{λ=1}$</span> (which one may write schematically as <span>$\frac{∂x_I}{∂v_J}$</span>) is computed:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.gejac" href="#squirrel.gejac"><code>squirrel.gejac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gejac( Xi::RealVec , Vi::RealVec , g::Function , δ::Real )</code></pre><p>The function <code>gejac</code> computes the endpoint of a geodesic and its Jacobian. The variables have the same meaning as those in <code>gsolve</code>.</p></div></section></article><p>Given <span>$\frac{∂x_I}{∂v_J}$</span>, the Jacobian matrix of the function <span>$f$</span> may be computed by way of the chain rule, as indicated in the schematic formula:</p><p class="math-container">\[J = \frac{∂f}{∂x_I}\frac{∂x_I}{∂v_J},\]</p><p>The following function applies the chain rule to compute the Jacobian matrix:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.geocJ" href="#squirrel.geocJ"><code>squirrel.geocJ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">geocJ( Zi::RealMtx , g::Function , δ::Real )</code></pre><p>The function <code>geocJ</code> computes the Jacobian of the function <code>zF</code> from the Jacobian endpoints computed in <code>gejac</code>.</p></div></section></article><h2 id="Root-finding-algorithm"><a class="docs-heading-anchor" href="#Root-finding-algorithm">Root finding algorithm</a><a id="Root-finding-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Root-finding-algorithm" title="Permalink"></a></h2><p>Given some function <span>$f(x)$</span>, the standard approach is the Newton method, which finds the roots according to the prescription:</p><p class="math-container">\[    x_{i+1} = x_i + {\bf J}^{-1}_{i} f(x_i)\]</p><p>where <span>${\bf J}^{-1}_{i}$</span> is the inverse of the Jacobian matrix <span>${\bf J}$</span> for <span>$f(x)$</span> evaluated at <span>$x_i$</span>. However, in situations which the computation of the Jacobian matrix <span>${\bf J}$</span> becomes expensive, one may instead employ the Broyden method, which is a quasi-Newton root finding method. The Broyden algorithm involves first computing the Jacobian matrix <span>${\bf J}$</span> and its inverse for <span>$f(x)$</span>. However, instead of computing the Jacobian matrix at each iteration (as is done in the Newton method), the Broyden algorithm updates the (inverse) Jacobian matrix according to the Sherman-Morrison update formula:</p><p class="math-container">\[    {\bf J}^{-1}_{i+1} 
    = 
        {\bf J}^{-1}_{i}
        +
        \frac{Δv^{T}_i - {\bf J}^{-1}_{i} Δf_i }
        {Δv^{T}_i {\bf J}^{-1}_{i} Δf_i }
        Δv^{T}_i {\bf J}^{-1}_{i},\]</p><p>which is implemented in the following function:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.JiSMU" href="#squirrel.JiSMU"><code>squirrel.JiSMU</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">JiSMU( ΔF::RealVec , Δx::RealVec , Ji::RealMtx )</code></pre><p>The function <code>JiSMU</code> implements the Sherman-Morrison update formula.</p></div></section></article><p>The Broyden update formula is implemented in the following function:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.bsolve" href="#squirrel.bsolve"><code>squirrel.bsolve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bsolve( F::Function , J::RealMtx , f0::RealVec , x0::RealVec ,
        nb::Int=24 )</code></pre><p>The function <code>bsolve</code> implements the Broyden algorithm; in particular, it finds the roots of the function <code>F(x)</code>, given the Jacobian matrix <code>J</code> and the initial guesses <code>f0</code> and <code>x0</code>. The parameter <code>nb</code> specifies the maximum number of iterations.</p></div></section></article><h2 id="Initial-data-finder"><a class="docs-heading-anchor" href="#Initial-data-finder">Initial data finder</a><a id="Initial-data-finder-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-data-finder" title="Permalink"></a></h2><p>The following function makes use of the preceding functions to construct the initial data for the four-velocities:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.idf" href="#squirrel.idf"><code>squirrel.idf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">idf( Zi::RealMtx , gfunc::Function , tol::Real , nb::Int )</code></pre><p>The function <code>idf</code> applies the Broyden algorithm to the function <code>zF</code>, using the Jacobian initially computed with <code>geocJ</code>.</p></div></section></article><h2 id="Locator-(Four-points)"><a class="docs-heading-anchor" href="#Locator-(Four-points)">Locator (Four points)</a><a id="Locator-(Four-points)-1"></a><a class="docs-heading-anchor-permalink" href="#Locator-(Four-points)" title="Permalink"></a></h2><p>Finally, the <code>locator4</code> function computes the intersection point from a set of four emission points <code>X</code> by first employing the <code>idf</code> function to obtain the initial data for the geodesics, and integrates the geodesics (up to unit affine parameter <span>$λ$</span>) to obtain the intersection point:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.locator4" href="#squirrel.locator4"><code>squirrel.locator4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">locator4( X::RealMtx , Xc::RealVec , gfunc::Function , tol::Real , nb::Int=24 , idv::Bool=false , V::RealMtx=zeros(Float64,4,4) )</code></pre><p>The function <code>locator4</code> computes the intersection point from a set of four emission points <code>X</code> using the guess <code>Xc</code>. The intersection point is computed by first finding the initial data using the function <code>idf</code>, then integrating geodesics to obtain the result. If an improved guess for the four-velocities is available, one can set <code>ìdv=true</code> and specify the four-velocities as column vectors in the matrix <code>V</code>.</p></div></section></article><h2 id="Locator-(n_e4-emission-points)"><a class="docs-heading-anchor" href="#Locator-(n_e4-emission-points)">Locator (<span>$n_e&gt;4$</span> emission points)</a><a id="Locator-(n_e4-emission-points)-1"></a><a class="docs-heading-anchor-permalink" href="#Locator-(n_e4-emission-points)" title="Permalink"></a></h2><p>If more than four emission points are available, the following function can generate <span>$C(n_{\rm e},4)$</span> sets of emission points (where <span>$C(n,k)$</span> is the binomial coefficient):</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.combX" href="#squirrel.combX"><code>squirrel.combX</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combX( X::RealMtx )</code></pre><p>The <code>combX</code> function constructs and returns a vector of <span>$4×4$</span> matrices consisting of all choices of 4 column vectors from the <span>$4×n_{\rm e}$</span> matrix <code>X</code>.</p></div></section></article><p>One feeds the output of <code>combX</code> into the <code>locator4</code> function to obtain <span>$C(n_{\rm e},4)$</span> solutions. The following outlier detection formula, which is based on the comparison with median values, can then be used to exclude large errors (the assumption here is that the large errors are infreqent):</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.odetc" href="#squirrel.odetc"><code>squirrel.odetc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">odetc( XC::Vector , ξ::Real=1e1 )</code></pre><p>The <code>odetc</code> function takes a vector of vectors as input and returns a vector of the vectors that differ by less than a threshold of <code>ξ</code>.</p></div></section></article><p>The following function implements the procedure described above, given a matrix of <span>$4×n_{\rm e}$</span> emission points <span>$X$</span>:</p><article class="docstring"><header><a class="docstring-binding" id="squirrel.locator" href="#squirrel.locator"><code>squirrel.locator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">locator( X::RealMtx , gfunc::Function , δ::Real , nb::Int=24 , tpflc::DataType=Double64 , outthresh::Real=1e1 , ne::Int=5 )</code></pre><p>The function <code>locator</code> computes the intersection point from a set of <code>ne&gt;4</code> emission points <code>X</code> by applying <code>locator4</code> to all combinations of 4 points out of <code>ne</code> in <code>X</code>. A basic outlier detection algorithm (implemented in the function <code>odetc</code>) is applied to reduce errors.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="geodesics.html">« Geodesic solver</a><a class="docs-footer-nextpage" href="evaluation.html">Evaluation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 11 December 2021 22:42">Saturday 11 December 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
